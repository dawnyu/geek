import{_ as a,C as n,o as s,c as l,H as e,w as o,k as i,a as p,Q as t}from"./chunks/framework.e34e23c1.js";const r=JSON.parse('{"title":"小程序生命周期","description":"","frontmatter":{"createTime":"2022/10/09","tags":"westore"},"headers":[],"relativePath":"interview-question/小程序生命周期.md","filePath":"全部文档/前端面试题/小程序/小程序生命周期.md","lastUpdated":1696860910000}'),c={name:"interview-question/小程序生命周期.md"},h=i("h1",{id:"小程序生命周期",tabindex:"-1"},[p("小程序生命周期 "),i("a",{class:"header-anchor",href:"#小程序生命周期","aria-label":'Permalink to "小程序生命周期"'},"​")],-1),d=t('<h2 id="一、是什么" tabindex="-1">一、是什么 <a class="header-anchor" href="#一、是什么" aria-label="Permalink to &quot;一、是什么&quot;">​</a></h2><p>跟vue、react框架一样，微信小程序框架也存在生命周期，实质也是一堆会在特定时期执行的函数 小程序中，生命周期主要分成了三部分：</p><ul><li>应用的生命周期</li><li>页面的生命周期</li><li>组件的生命周期</li></ul><h3 id="应用的生命周期" tabindex="-1">应用的生命周期 <a class="header-anchor" href="#应用的生命周期" aria-label="Permalink to &quot;应用的生命周期&quot;">​</a></h3><p>小程序的生命周期函数是在app.js里面调用的，通过App(Object)函数用来注册一个小程序，指定其小程序的生命周期回调</p><h3 id="页面的生命周期" tabindex="-1">页面的生命周期 <a class="header-anchor" href="#页面的生命周期" aria-label="Permalink to &quot;页面的生命周期&quot;">​</a></h3><p>页面生命周期函数就是当你每进入/切换到一个新的页面的时候，就会调用的生命周期函数，同样通过App(Object)函数用来注册一个页面</p><h3 id="组件的生命周期" tabindex="-1">组件的生命周期 <a class="header-anchor" href="#组件的生命周期" aria-label="Permalink to &quot;组件的生命周期&quot;">​</a></h3><p>组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发，通过Component(Object)进行注册组件</p><h2 id="二、有哪些" tabindex="-1">二、有哪些 <a class="header-anchor" href="#二、有哪些" aria-label="Permalink to &quot;二、有哪些&quot;">​</a></h2><h3 id="应用的生命周期-1" tabindex="-1">应用的生命周期 <a class="header-anchor" href="#应用的生命周期-1" aria-label="Permalink to &quot;应用的生命周期&quot;">​</a></h3><p>生命周期 说明</p><ul><li>onLaunch 小程序初始化完成时触发，全局只触发一次</li><li>onShow 小程序启动，或从后台进入前台显示时触发</li><li>onHide 小程序从前台进入后台时触发</li><li>onError 小程序发生脚本错误或 API 调用报错时触发</li><li>onPageNotFound 小程序要打开的页面不存在时触发</li><li>onUnhandledRejection() 小程序有未处理的 Promise 拒绝时触发</li><li>onThemeChange 系统切换主题时触发</li></ul><h3 id="页面的生命周期-1" tabindex="-1">页面的生命周期 <a class="header-anchor" href="#页面的生命周期-1" aria-label="Permalink to &quot;页面的生命周期&quot;">​</a></h3><ul><li>生命周期 说明 作用</li><li>onLoad 生命周期回调—监听页面加载 发送请求获取数据</li><li>onShow 生命周期回调—监听页面显示 请求数据</li><li>onReady 生命周期回调—监听页面初次渲染完成 获取页面元素（少用）</li><li>onHide 生命周期回调—监听页面隐藏 终止任务，如定时器或者播放音乐</li><li>onUnload 生命周期回调—监听页面卸载 终止任务</li></ul><h3 id="组件的生命周期-1" tabindex="-1">组件的生命周期 <a class="header-anchor" href="#组件的生命周期-1" aria-label="Permalink to &quot;组件的生命周期&quot;">​</a></h3><p>生命周期 说明</p><ul><li>created 生命周期回调—监听页面加载</li><li>attached 生命周期回调—监听页面显示</li><li>ready 生命周期回调—监听页面初次渲染完成</li><li>moved 生命周期回调—监听页面隐藏</li><li>detached 生命周期回调—监听页面卸载</li><li>error 每当组件方法抛出错误时执行</li></ul><h3 id="注意的是" tabindex="-1">注意的是 <a class="header-anchor" href="#注意的是" aria-label="Permalink to &quot;注意的是&quot;">​</a></h3><ul><li>组件实例刚刚被创建好时， created 生命周期被触发，此时，组件数据 this.data 就是在 Component 构造器中定义的数据 data ， 此时不能调用 setData</li><li>在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行</li><li>在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发 还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理，这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义，如下：</li></ul><h3 id="生命周期-说明" tabindex="-1">生命周期 说明 <a class="header-anchor" href="#生命周期-说明" aria-label="Permalink to &quot;生命周期 说明&quot;">​</a></h3><p>show 组件所在的页面被展示时执行 hide 组件所在的页面被隐藏时执行 代码如下：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">Component</span><span style="color:#E1E4E8;">({</span></span>\n<span class="line"><span style="color:#E1E4E8;">  pageLifetimes: {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">show</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">() {</span></span>\n<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 页面被展示</span></span>\n<span class="line"><span style="color:#E1E4E8;">    },</span></span>\n<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">hide</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">() {</span></span>\n<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 页面被隐藏</span></span>\n<span class="line"><span style="color:#E1E4E8;">    },</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">Component</span><span style="color:#24292E;">({</span></span>\n<span class="line"><span style="color:#24292E;">  pageLifetimes: {</span></span>\n<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">show</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">() {</span></span>\n<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 页面被展示</span></span>\n<span class="line"><span style="color:#24292E;">    },</span></span>\n<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">hide</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">() {</span></span>\n<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 页面被隐藏</span></span>\n<span class="line"><span style="color:#24292E;">    },</span></span>\n<span class="line"><span style="color:#24292E;">  }</span></span>\n<span class="line"><span style="color:#24292E;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="三、执行过程" tabindex="-1">三、执行过程 <a class="header-anchor" href="#三、执行过程" aria-label="Permalink to &quot;三、执行过程&quot;">​</a></h2><h3 id="应用的生命周期执行过程" tabindex="-1">应⽤的⽣命周期执行过程 <a class="header-anchor" href="#应用的生命周期执行过程" aria-label="Permalink to &quot;应⽤的⽣命周期执行过程&quot;">​</a></h3><ul><li>⽤户⾸次打开⼩程序，触发 onLaunch（全局只触发⼀次）</li><li>⼩程序初始化完成后，触发onShow⽅法，监听⼩程序显示</li><li>⼩程序从前台进⼊后台，触发 onHide⽅法</li><li>⼩程序从后台进⼊前台显示，触发 onShow⽅法</li><li>⼩程序后台运⾏⼀定时间，或系统资源占⽤过⾼，会被销毁</li></ul><h3 id="⻚面生命周期的执行过程" tabindex="-1">⻚⾯⽣命周期的执行过程 <a class="header-anchor" href="#⻚面生命周期的执行过程" aria-label="Permalink to &quot;⻚⾯⽣命周期的执行过程&quot;">​</a></h3><ul><li>⼩程序注册完成后，加载⻚⾯，触发onLoad⽅法</li><li>⻚⾯载⼊后触发onShow⽅法，显示⻚⾯</li><li>⾸次显示⻚⾯，会触发onReady⽅法，渲染⻚⾯元素和样式，⼀个⻚⾯只会调⽤⼀次</li><li>当⼩程序后台运⾏或跳转到其他⻚⾯时，触发onHide⽅法</li><li>当⼩程序有后台进⼊到前台运⾏或重新进⼊⻚⾯时，触发onShow⽅法</li><li>当使⽤重定向⽅法 wx.redirectTo() 或关闭当前⻚返回上⼀⻚wx.navigateBack()，触发onUnload</li></ul><h3 id="当存在也应用生命周期和页面周期的时候-相关的执行顺序如下" tabindex="-1">当存在也应用生命周期和页面周期的时候，相关的执行顺序如下 <a class="header-anchor" href="#当存在也应用生命周期和页面周期的时候-相关的执行顺序如下" aria-label="Permalink to &quot;当存在也应用生命周期和页面周期的时候，相关的执行顺序如下&quot;">​</a></h3><ul><li>打开小程序：(App)onLaunch --&gt; (App)onShow --&gt; (Pages)onLoad --&gt; (Pages)onShow --&gt; (pages)onRead</li><li>进入下一个页面：(Pages)onHide --&gt; (Next)onLoad --&gt; (Next)onShow --&gt; (Next)onReady</li><li>返回上一个页面：(curr)onUnload --&gt; (pre)onShow</li><li>离开小程序：(App)onHide</li><li>再次进入：小程序未销毁 --&gt; (App)onShow(执行上面的顺序），小程序被销毁，（App)onLaunch重新开始执行.</li></ul>',30);const u=a(c,[["render",function(a,i,p,t,r,c){const u=n("ArticleMetadata"),b=n("ClientOnly");return s(),l("div",null,[h,e(b,null,{default:o((()=>[e(u)])),_:1}),d])}]]);export{r as __pageData,u as default};
