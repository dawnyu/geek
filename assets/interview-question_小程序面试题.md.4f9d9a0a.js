import{_ as a,C as e,o as i,c as l,H as t,w as r,k as o,a as s,Q as h}from"./chunks/framework.bc643b65.js";const n=JSON.parse('{"title":"小程序面试题","description":"","frontmatter":{"createTime":"2022/10/09","tag":"westore"},"headers":[],"relativePath":"interview-question/小程序面试题.md","filePath":"s/前端面试题/小程序/小程序面试题.md","lastUpdated":1696495218000}'),d={name:"interview-question/小程序面试题.md"},c=o("h1",{id:"小程序面试题",tabindex:"-1"},[s("小程序面试题 "),o("a",{class:"header-anchor",href:"#小程序面试题","aria-label":'Permalink to "小程序面试题"'},"​")],-1),u=h('<h2 id="小程序是双线程架构还是单线程架构" tabindex="-1">小程序是双线程架构还是单线程架构？ <a class="header-anchor" href="#小程序是双线程架构还是单线程架构" aria-label="Permalink to &quot;小程序是双线程架构还是单线程架构？&quot;">​</a></h2><ol><li>小程序的架构模型有别与传统web单线程架构，小程序为双线程架构。</li><li>微信小程序的渲染层与逻辑层分别由两个线程管理，渲染层的界面使用 webview 进行渲染；逻辑层采用 JSCore运行JavaScript代码 <ol><li>由于渲染层与逻辑层分开，一个小程序有多个界面，所以渲染层对应存在多个webview。</li><li>这两个线程之间由Native层进行统一处理。无论是线程之间的通讯、数据的传递、网络请求都由Native层做转发。</li></ol></li><li>这里的webview是什么呢 <ol><li>可以想象webview是一个嵌入式的浏览器，是嵌入在原生应用中的</li><li>webview 用来展示网页的 view 组件，使用 webkit 渲染引擎来展示，并且支持前进后退、浏览历史、放大缩小、等更多功能。</li></ol></li><li>并且小程序 会有 多个 webview <ol><li>为了更加接近原生应用APP的用户体验。多个webview可以理解为多页面应用，有别于单页面应用SPA，SPA渲染页面是通过路由识别随后动态将页面挂载到root节点中去</li><li>如果单页面应用打开一个新的页面，需要先卸载掉当前页面结构，并且重新渲染。很显然原生APP并不是这个样子，比较明显的特征为从页面右侧向左划入一个新的页面，并且我们可以同时看到两个页面。</li></ol></li><li>Native 主要做了什么 <ol><li>Native层除了做一些资源的动态注入，还负责着很多的事情，请求的转发，离线存储，组件渲染等等。</li><li>界面主要由成熟的 Web 技术渲染，辅之以大量的接口提供丰富的客户端原生能力。</li></ol></li></ol><h2 id="小程序中-为什么不能在-onlaunch-里面阻止页面显示-达到有必须要最先请求的-接口响应-在展示-小程序页面" tabindex="-1">小程序中 为什么不能在 onLaunch 里面阻止页面显示 达到有必须要最先请求的 接口响应 在展示 小程序页面 <a class="header-anchor" href="#小程序中-为什么不能在-onlaunch-里面阻止页面显示-达到有必须要最先请求的-接口响应-在展示-小程序页面" aria-label="Permalink to &quot;小程序中 为什么不能在 onLaunch 里面阻止页面显示 达到有必须要最先请求的 接口响应 在展示 小程序页面&quot;">​</a></h2><ol><li>因为小程序是双线程架构</li><li>一个线程解析 运行 js</li><li>一个线程用来渲染 webview</li><li>所以不像 web 端等 单线程 架构 js代码无法阻塞 webview 的展示</li></ol><h3 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h3><ol><li>通过自定义 tab-bar nav-bar 还有一个每个页面都在使用的 公共组件可以实现</li><li>统一通过 变量所有组件默认隐藏</li><li>等到接口回来再去修改这个统一变量</li><li>注意边界 和容错处理 不要因为接口报错导致页面一直空白</li></ol><h2 id="小程序-view-text-到底是什么-又是如何实现的" tabindex="-1">小程序 view text 到底是什么 ？ 又是如何实现的 ？ <a class="header-anchor" href="#小程序-view-text-到底是什么-又是如何实现的" aria-label="Permalink to &quot;小程序 view text 到底是什么 ？ 又是如何实现的 ？&quot;">​</a></h2><ol><li>小程序 的 view text 标签是通过 渲染层中编译后的 Exparser 自定义组件标记</li><li>会通过 $gwx() 函数 结合一些文件路径 动态数据生成 virtualDOM 虚拟dom</li><li>text 生成 virtualDOM 的 tag 就是 wx-text</li><li>view 生成 virtualDOM 的 tag 就是 wx-view</li></ol><h2 id="小程序中-为什么不能直接操作-dom-节点" tabindex="-1">小程序中 为什么不能直接操作 dom 节点？ <a class="header-anchor" href="#小程序中-为什么不能直接操作-dom-节点" aria-label="Permalink to &quot;小程序中 为什么不能直接操作 dom 节点？&quot;">​</a></h2><ol><li>为了解决安全管控问题，小程序阻止开发者使用一些浏览器提供的比如跳转页面、操作DOM、动态执行脚本的开放性接口。</li><li>如果这些东西一个一个地去禁用，那么势必会进入一个糟糕的循环，因为javascript实在是太灵活了，浏览器的接口也太丰富了，很容易就遗漏一些危险的接口，而且就算是禁用掉了所有感觉到危险的接口，也势必防不住浏览器内核的下次更新。指不定又会出现一些漏洞。</li><li>要彻底解决这个问题，必须提供一个沙箱环境来运行开发者的JavaScript 代码。这个沙箱环境不能有任何浏览器相关接口，只提供纯JavaScript 的解释执行环境</li><li>那么像HTML5中的ServiceWorker、WebWorker特性就符合这样的条件，这两者都是启用另一线程来执行 javaScript。</li><li>考虑到小程序是一个多 webView 的架构，每一个小程序页面都是不同的webView 渲染后显示的，在这个架构下不好去用某个webView中的ServiceWorker去管理所有的小程序页面。</li><li>得益于客户端系统有javaScript 的解释引擎（在iOS下使用内置的 javaScriptCore框架，在安卓则是用腾讯x5内核提供的JsCore环境），可以创建一个单独的线程去执行 javaScript，在这个环境下执行的都是有关小程序业务逻辑的代码</li></ol><h2 id="小程序-是单页面应用还是多页面应用-为什么" tabindex="-1">小程序 是单页面应用还是多页面应用 ？ 为什么 ？ <a class="header-anchor" href="#小程序-是单页面应用还是多页面应用-为什么" aria-label="Permalink to &quot;小程序 是单页面应用还是多页面应用 ？  为什么 ？&quot;">​</a></h2><ol><li>多页面应用 为了更好的让交互和原生 app 一样</li><li>左右滑动的同时 用户可以同时看到 两个页面</li></ol><h2 id="小程序中-为什么限制了-页面栈-最多数量" tabindex="-1">小程序中 为什么限制了 页面栈 最多数量？ <a class="header-anchor" href="#小程序中-为什么限制了-页面栈-最多数量" aria-label="Permalink to &quot;小程序中 为什么限制了 页面栈 最多数量？&quot;">​</a></h2><ol><li>因为小程序是多页面架构设计 为了更好的让交互和原生 app 一样</li><li>如果不限制 页面栈 数量 就会导致性能问题 所以限制了 最大页面栈数量 防止产生过多的 webview</li></ol><h2 id="小程序中-是怎么实现-自适应-rpx" tabindex="-1">小程序中 是怎么实现 自适应 rpx ？ <a class="header-anchor" href="#小程序中-是怎么实现-自适应-rpx" aria-label="Permalink to &quot;小程序中 是怎么实现 自适应 rpx  ？&quot;">​</a></h2><p>rpx （responsive pixel）直译为：响应像素。写过小程序的都知道这个单位，可以自动适配所有大小的屏幕，而不必使用一些第三方插件进行响应式布局。</p><h3 id="编译" tabindex="-1">编译 <a class="header-anchor" href="#编译" aria-label="Permalink to &quot;编译&quot;">​</a></h3><p>WXSS并不可以直接执行在webview层进行渲染，而是通过了一层编译。我们接下来就带大家编译一个WXSS看一下。 <img src="/assets/rpx.386475c7.webp" alt="图片"></p><h3 id="wcsc" tabindex="-1">WCSC <a class="header-anchor" href="#wcsc" aria-label="Permalink to &quot;WCSC&quot;">​</a></h3><p>编译的工具名字叫WCSC，这个编译的过程是在微信开发者工具端执行的，那么这个编译工具在哪呢，我们来找一下。在微信开发者工具的控制台界面，输入help()命令可见如所示界面。 index.wxss文件会先通过WCSC可执行程序文件编译成js文件。并不是直接编译成css文件。</p><h3 id="三部分" tabindex="-1">三部分 <a class="header-anchor" href="#三部分" aria-label="Permalink to &quot;三部分&quot;">​</a></h3><p>三部分加一起就是完整的代码。 第一部分：设备信息。 这个部分用于获取一套基本设备信息，包含设备高度、设备宽度、物理像素与CSS像素比例、设备方向。 第二部分： 转换rpx px = rpx / 基础设备宽度 750 * 设备实际宽度</p><h3 id="第三部分-setcsstohead" tabindex="-1">第三部分：setCssToHead <a class="header-anchor" href="#第三部分-setcsstohead" aria-label="Permalink to &quot;第三部分：setCssToHead&quot;">​</a></h3><p><img src="/assets/setCssToHead.011cb8c3.png" alt="图片"></p><p>可以看到其中在index.wxss中写rpx单位的属性都变成了区间的样子[0, 128]、[0, 20]。其他单位并没有转换。这样的话就可以方便的识别哪里写了rpx单位，然后执行第二部分的transformRPX方法即可。 makeup组装之后，创建 style 标记，插入到 head 中。 编译后的代码是通过eval方法注入执行的。这样的话完成了WXSS的一整套流程。</p><h2 id="小程序-分别有-哪三种-框架" tabindex="-1">小程序 分别有 哪三种 框架 ？ <a class="header-anchor" href="#小程序-分别有-哪三种-框架" aria-label="Permalink to &quot;小程序 分别有 哪三种 框架 ？&quot;">​</a></h2><h3 id="预编译" tabindex="-1">预编译 <a class="header-anchor" href="#预编译" aria-label="Permalink to &quot;预编译&quot;">​</a></h3><p>什么是预编译的框架呢？还记得我们讲解WXSS的时候，WXSS的文件会编译成js再执行。像这种执行前就进行编译的手段就叫做预编译。这种框架就是预编译框架。wepy、taro就是这样的框架。 预编译框架的核心思想就是DSL+ 语法解析。刚看了一下taro最新的文档，已经支持react hooks这样的写法了。 小程序预编译框架的原理就如上述讲解，我们可以想象一下预编译框架的坏处有什么呢？</p><ul><li>react或者vue后期再出一些新特性的话，预编译框架都需要在进行语法解析扩展编写。</li><li>兼容问题，比如小程序不支持的一些属性，如果不支持，预编译框架要进行兼容。</li></ul><h3 id="半编译-半运行" tabindex="-1">半编译 半运行 <a class="header-anchor" href="#半编译-半运行" aria-label="Permalink to &quot;半编译 半运行&quot;">​</a></h3><p>半编译半运行框架有什么呢，美团开发的mpvue。 那么就可以修改patch流程不直接生成真实node，而是触发setData来更新视图层。 可以想象一下，如果把vue的template编译成WXML就变为了小程序的视图层。vue本身预编译的代码为js，这个js是可以在逻辑层中运行由于js-core，然后当数据变动的时候走vue的渲染流程，patch流程改为setData来触发视图层更新。这样的话是完全没问题的。 所以为什么这个框架的名称叫半编译半运行框架，半编译讲的是vue的template需要单独编译为wxml，半运行讲的是vue整体的特性都会在逻辑层中运行。为了符合小程序的渲染框架，修改了vue的框架，最终达到了这个目的。</p><h3 id="运行时框架" tabindex="-1">运行时框架 <a class="header-anchor" href="#运行时框架" aria-label="Permalink to &quot;运行时框架&quot;">​</a></h3><p>在小程序双线程架构中，渲染层是没有开放任何操作DOM的api给逻辑层的。逻辑层是没有办法通过操作DOM来改变视图的。所以我们看到了半编译半运行时框架通过半编译，把vue的template模版提前编译为wxml，然后通过setData把data数据传输过去。 然而纯运行时框架就是要解决这个半编译的问题。 届时有几个问题需要解决：</p><ul><li>通讯方式只能通过setData到渲染层</li><li>vue、react最终需要操作DOM</li></ul>',34);const p=a(d,[["render",function(a,o,s,h,n,d){const p=e("ArticleMetadata"),b=e("ClientOnly");return i(),l("div",null,[c,t(b,null,{default:r((()=>[t(p)])),_:1}),u])}]]);export{n as __pageData,p as default};
