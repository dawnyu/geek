import{_ as s,C as n,o as a,c as e,H as l,w as p,k as r,a as i,Q as t}from"./chunks/framework.e34e23c1.js";const o=JSON.parse('{"title":"浅析requestAnimationFrame的用法与优化","description":"requestAnimationFrame的常见用法与优化","frontmatter":{"layout":"Article","title":"浅析requestAnimationFrame的用法与优化","head":[["meta",{"name":"description","content":"requestAnimationFrame的常见用法与优化"}],["meta",{"name":"keywords","content":"requestAnimationFrame是什么,requestAnimationFrame怎么优化"}]],"date":"2023/10/20","tags":"JavaScript","category":"技术专栏","intro":"requestAnimationFrame是浏览器用于定时循环操作的一个API,通常用于动画和游戏开发。它会把每一帧中的所有DOM操作集中起来,在重绘之前一次性更新,并且关联到浏览器的重绘操作。"},"headers":[],"relativePath":"article/浅析requestAnimationFrame的用法与优化.md","filePath":"全部文档/技术专栏/前端/浅析requestAnimationFrame的用法与优化.md","lastUpdated":1697810497000}'),c={name:"article/浅析requestAnimationFrame的用法与优化.md"},m=r("h1",{id:"浅析requestanimationframe的用法与优化",tabindex:"-1"},[i("浅析requestAnimationFrame的用法与优化 "),r("a",{class:"header-anchor",href:"#浅析requestanimationframe的用法与优化","aria-label":'Permalink to "浅析requestAnimationFrame的用法与优化"'},"​")],-1),u=t('<h2 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h2><h3 id="什么是requestanimationframe" tabindex="-1">什么是requestAnimationFrame <a class="header-anchor" href="#什么是requestanimationframe" aria-label="Permalink to &quot;什么是requestAnimationFrame&quot;">​</a></h3><p><code>requestAnimationFrame</code>是浏览器用于定时循环操作的一个API,通常用于动画和游戏开发。它会把每一帧中的所有DOM操作集中起来,在重绘之前一次性更新,并且关联到浏览器的重绘操作。</p><h3 id="为什么使用requestanimationframe而不是settimeout或setinterval" tabindex="-1">为什么使用requestAnimationFrame而不是setTimeout或setInterval <a class="header-anchor" href="#为什么使用requestanimationframe而不是settimeout或setinterval" aria-label="Permalink to &quot;为什么使用requestAnimationFrame而不是setTimeout或setInterval&quot;">​</a></h3><p>与<code>setTimeout</code>或<code>setInterval</code>相比,<code>requestAnimationFrame</code>具有以下优势:</p><ul><li>通过系统时间间隔来调用回调函数，无需担心系统负载和阻塞问题，系统会自动调整回调频率。</li><li>由浏览器内部进行调度和优化，性能更高，消耗的CPU和GPU资源更少。</li><li>避免帧丢失现象，确保回调连续执行，实现更流畅的动画效果。</li><li>自动合并多个回调，避免不必要的开销。</li><li>与浏览器的刷新同步，不会在浏览器页面不可见时执行回调。</li></ul><h3 id="requestanimationframe的优势和适用场景" tabindex="-1">requestAnimationFrame的优势和适用场景 <a class="header-anchor" href="#requestanimationframe的优势和适用场景" aria-label="Permalink to &quot;requestAnimationFrame的优势和适用场景&quot;">​</a></h3><p><code>requestAnimationFrame</code>最适用于需要连续高频执行的动画,如游戏开发,数据可视化动画等。它与浏览器刷新周期保持一致,不会因为间隔时间不均匀而导致动画卡顿。</p><h2 id="使用方法" tabindex="-1">使用方法 <a class="header-anchor" href="#使用方法" aria-label="Permalink to &quot;使用方法&quot;">​</a></h2><h3 id="requestanimationframe的基本语法" tabindex="-1">requestAnimationFrame的基本语法 <a class="header-anchor" href="#requestanimationframe的基本语法" aria-label="Permalink to &quot;requestAnimationFrame的基本语法&quot;">​</a></h3><p><code>requestAnimationFrame</code>接收一个回调函数作为参数,该回调函数会在浏览器下一次重绘前执行。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">const animation = () =&gt; {</span></span>\n<span class="line"><span style="color:#e1e4e8;">  // 执行动画</span></span>\n<span class="line"><span style="color:#e1e4e8;">  requestAnimationFrame(animation); </span></span>\n<span class="line"><span style="color:#e1e4e8;">}</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">requestAnimationFrame(animation);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">const animation = () =&gt; {</span></span>\n<span class="line"><span style="color:#24292e;">  // 执行动画</span></span>\n<span class="line"><span style="color:#24292e;">  requestAnimationFrame(animation); </span></span>\n<span class="line"><span style="color:#24292e;">}</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">requestAnimationFrame(animation);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>上面代码会不停调用<code>requestAnimationFrame</code>,在每次浏览器重绘前执行回调函数,实现连续动画效果。</p><h3 id="如何在动画中使用requestanimationframe" tabindex="-1">如何在动画中使用requestAnimationFrame <a class="header-anchor" href="#如何在动画中使用requestanimationframe" aria-label="Permalink to &quot;如何在动画中使用requestAnimationFrame&quot;">​</a></h3><p>可以在回调函数里更新动画的状态,然后清除上一帧,绘制新状态的这一帧:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">let angle = 0; </span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">const render = () =&gt; {</span></span>\n<span class="line"><span style="color:#e1e4e8;">  ctx.clearRect(0, 0, width, height); // 清除上一帧</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">  // 更新状态</span></span>\n<span class="line"><span style="color:#e1e4e8;">  angle += delta;</span></span>\n<span class="line"><span style="color:#e1e4e8;">  </span></span>\n<span class="line"><span style="color:#e1e4e8;">  ctx.beginPath();</span></span>\n<span class="line"><span style="color:#e1e4e8;">  ctx.arc(x, y, radius, 0, angle); </span></span>\n<span class="line"><span style="color:#e1e4e8;">  ctx.stroke();</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">  requestAnimationFrame(render);</span></span>\n<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">let angle = 0; </span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">const render = () =&gt; {</span></span>\n<span class="line"><span style="color:#24292e;">  ctx.clearRect(0, 0, width, height); // 清除上一帧</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">  // 更新状态</span></span>\n<span class="line"><span style="color:#24292e;">  angle += delta;</span></span>\n<span class="line"><span style="color:#24292e;">  </span></span>\n<span class="line"><span style="color:#24292e;">  ctx.beginPath();</span></span>\n<span class="line"><span style="color:#24292e;">  ctx.arc(x, y, radius, 0, angle); </span></span>\n<span class="line"><span style="color:#24292e;">  ctx.stroke();</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">  requestAnimationFrame(render);</span></span>\n<span class="line"><span style="color:#24292e;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这样通过在每次回调中更新参数,就可以实现对象的连续动画了。</p><h3 id="requestanimationframe的回调函数参数" tabindex="-1">requestAnimationFrame的回调函数参数 <a class="header-anchor" href="#requestanimationframe的回调函数参数" aria-label="Permalink to &quot;requestAnimationFrame的回调函数参数&quot;">​</a></h3><p><code>requestAnimationFrame</code>的回调函数会收到一个参数,这个参数是一个时间戳,单位为毫秒,代表<code>requestAnimationFrame</code>被触发的时间。可以根据这个时间戳计算两帧的时间间隔,来调整动画速度。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">let prevTimestamp;</span></span>\n<span class="line"><span style="color:#e1e4e8;">const render = timestamp =&gt; {</span></span>\n<span class="line"><span style="color:#e1e4e8;">  if (!prevTimestamp) prevTimestamp = timestamp;</span></span>\n<span class="line"><span style="color:#e1e4e8;">  const delta = timestamp - prevTimestamp;</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">  // 根据时间间隔计算速度</span></span>\n<span class="line"><span style="color:#e1e4e8;">  x += speed * delta;</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">  prevTimestamp = timestamp;</span></span>\n<span class="line"><span style="color:#e1e4e8;">  requestAnimationFrame(render);</span></span>\n<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">let prevTimestamp;</span></span>\n<span class="line"><span style="color:#24292e;">const render = timestamp =&gt; {</span></span>\n<span class="line"><span style="color:#24292e;">  if (!prevTimestamp) prevTimestamp = timestamp;</span></span>\n<span class="line"><span style="color:#24292e;">  const delta = timestamp - prevTimestamp;</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">  // 根据时间间隔计算速度</span></span>\n<span class="line"><span style="color:#24292e;">  x += speed * delta;</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">  prevTimestamp = timestamp;</span></span>\n<span class="line"><span style="color:#24292e;">  requestAnimationFrame(render);</span></span>\n<span class="line"><span style="color:#24292e;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h2><h3 id="避免在requestanimationframe回调函数中进行大量计算" tabindex="-1">避免在requestAnimationFrame回调函数中进行大量计算 <a class="header-anchor" href="#避免在requestanimationframe回调函数中进行大量计算" aria-label="Permalink to &quot;避免在requestAnimationFrame回调函数中进行大量计算&quot;">​</a></h3><p>由于<code>requestAnimationFrame</code>的回调会在一个高优先级的线程中被同步执行,如果回调函数中有大量计算,会导致此线程被阻塞,从而引起页面卡顿。</p><p>也就是如果 <code>requestAnimationFrame</code> 的回调函数执行时间超过一帧（通常是 16.67 毫秒，因为浏览器通常以每秒约 60 帧的速度刷新），则可能会导致动画性能下降，可能出现掉帧的情况，最终影响用户体验。这是因为浏览器每帧的时间是有限的，如果回调函数执行时间过长，就会导致下一帧的准备和绘制时间受到压缩，导致动画卡顿。</p><p>通常，应该尽量避免在 <code>requestAnimationFrame</code> 的回调函数中执行耗时的操作。为了解决这个问题，可以采取以下一些策略：</p><ol><li><p><strong>优化回调函数</strong>: 使回调函数尽可能简短，避免不必要的计算或循环。在回调中只执行与动画相关的必要操作。</p></li><li><p><strong>分帧处理</strong>: 如果动画需要处理大量数据或计算复杂的操作，可以将这些操作分散到多个 <code>requestAnimationFrame</code> 回调中，以避免长时间的占用。</p></li><li><p><strong>Web Workers</strong>: 将耗时的计算放在独立的 Web Worker 线程中执行，以不影响主线程和动画渲染。</p></li><li><p><strong>帧率控制</strong>: 如果回调函数耗时较长，可以根据回调函数的实际执行时间来控制动画的帧率。减小动画对象的速度或者减少渲染质量，以适应当前性能。</p></li><li><p><strong>监测性能</strong>: 使用浏览器开发者工具来监测性能，以找出哪些操作导致了回调函数执行时间过长。</p></li></ol><p>总之，确保 <code>requestAnimationFrame</code> 回调函数的执行时间尽量短，以确保动画的流畅性和性能。</p><h3 id="使用硬件加速优化动画性能" tabindex="-1">使用硬件加速优化动画性能 <a class="header-anchor" href="#使用硬件加速优化动画性能" aria-label="Permalink to &quot;使用硬件加速优化动画性能&quot;">​</a></h3><p>启用<code>GPU</code>加速渲染,可以显著提升动画性能。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">.animated {</span></span>\n<span class="line"><span style="color:#e1e4e8;">  transform: translateZ(0); /* 开启硬件加速 */  </span></span>\n<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">.animated {</span></span>\n<span class="line"><span style="color:#24292e;">  transform: translateZ(0); /* 开启硬件加速 */  </span></span>\n<span class="line"><span style="color:#24292e;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="如何在不同设备上实现平滑的动画效果" tabindex="-1">如何在不同设备上实现平滑的动画效果 <a class="header-anchor" href="#如何在不同设备上实现平滑的动画效果" aria-label="Permalink to &quot;如何在不同设备上实现平滑的动画效果&quot;">​</a></h3><p>可根据<code>requestAnimationFrame</code>回调的时间戳,计算这一帧与上一帧的间隔时间<code>delta</code>,并根据<code>delta</code>的值采取不同的优化手段:</p><ul><li><code>delta</code>特别小,说明这一帧花费时间过长,可能导致掉帧,可以降低动画对象的移动速度或图像质量</li><li><code>delta</code>逐渐变大,说明动画逐渐卡顿,可以降低动画对象数量或复杂度</li><li><code>delta</code>波动较大,说明系统资源不足,可以采用简单的动画作为降级策略</li></ul><h2 id="与其他动画库的比较" tabindex="-1">与其他动画库的比较 <a class="header-anchor" href="#与其他动画库的比较" aria-label="Permalink to &quot;与其他动画库的比较&quot;">​</a></h2><h3 id="requestanimationframe与settimeout-setinterval的区别" tabindex="-1">requestAnimationFrame与setTimeout/setInterval的区别 <a class="header-anchor" href="#requestanimationframe与settimeout-setinterval的区别" aria-label="Permalink to &quot;requestAnimationFrame与setTimeout/setInterval的区别&quot;">​</a></h3><ul><li><code>setTimeout/setInterval</code>是固定时间间隔触发, <code>requestAnimationFrame</code>依赖系统刷新调度</li><li><code>setTimeout/setInterval</code>会无视页面是否可见, <code>requestAnimationFrame</code>会停止刷新</li><li><code>setTimeout/setInterval</code>难以避免丢帧问题,<code>requestAnimationFrame</code>与刷新同步避免丢帧</li></ul><h3 id="requestanimationframe与css动画的结合使用" tabindex="-1">requestAnimationFrame与CSS动画的结合使用 <a class="header-anchor" href="#requestanimationframe与css动画的结合使用" aria-label="Permalink to &quot;requestAnimationFrame与CSS动画的结合使用&quot;">​</a></h3><p><code>requestAnimationFrame</code>可用于更新动画状态,实现复杂动画逻辑,而CSS动画用于声明式定义动画的样式变化,两者可配合实现更丰富的动画效果。</p><h2 id="实际应用" tabindex="-1">实际应用 <a class="header-anchor" href="#实际应用" aria-label="Permalink to &quot;实际应用&quot;">​</a></h2><h3 id="使用requestanimationframe实现常见动画效果" tabindex="-1">使用requestAnimationFrame实现常见动画效果 <a class="header-anchor" href="#使用requestanimationframe实现常见动画效果" aria-label="Permalink to &quot;使用requestAnimationFrame实现常见动画效果&quot;">​</a></h3><p>可使用 <code>requestAnimationFrame</code> 实现对象轨迹动画、SVG图形动画、加载动画等效果。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">// 小球拖尾效果</span></span>\n<span class="line"><span style="color:#e1e4e8;">const positions = [];</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">const render = () =&gt; {</span></span>\n<span class="line"><span style="color:#e1e4e8;">  // 添加新位置</span></span>\n<span class="line"><span style="color:#e1e4e8;">  positions.push({x, y});</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">  if (positions.length &gt; 10){</span></span>\n<span class="line"><span style="color:#e1e4e8;">    positions.shift(); </span></span>\n<span class="line"><span style="color:#e1e4e8;">  }</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">  // 渲染小球</span></span>\n<span class="line"><span style="color:#e1e4e8;">  ctx.clearRect(0, 0, width, height);</span></span>\n<span class="line"><span style="color:#e1e4e8;">  positions.forEach(pos =&gt; ctx.fillRect(pos.x, pos.y, 10, 10));</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">  requestAnimationFrame(render);</span></span>\n<span class="line"><span style="color:#e1e4e8;">}</span></span>\n<span class="line"><span style="color:#e1e4e8;">// SVG绘制动画</span></span>\n<span class="line"><span style="color:#e1e4e8;">let length = 0;</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">const render = () =&gt; {</span></span>\n<span class="line"><span style="color:#e1e4e8;">  length += 4;</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">  svgLine.setAttribute(&quot;stroke-dasharray&quot;, length);</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">  if (length &lt; 300) {</span></span>\n<span class="line"><span style="color:#e1e4e8;">    requestAnimationFrame(render);</span></span>\n<span class="line"><span style="color:#e1e4e8;">  }</span></span>\n<span class="line"><span style="color:#e1e4e8;">}</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">requestAnimationFrame(render); </span></span>\n<span class="line"><span style="color:#e1e4e8;">// 进度条加载动画  </span></span>\n<span class="line"><span style="color:#e1e4e8;">let progress = 0;</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">const render = () =&gt; {</span></span>\n<span class="line"><span style="color:#e1e4e8;">  progress += 1; </span></span>\n<span class="line"><span style="color:#e1e4e8;">  loadBar.style.width = progress + &#39;%&#39;;</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">  if(progress &lt; 100) {</span></span>\n<span class="line"><span style="color:#e1e4e8;">    requestAnimationFrame(render);</span></span>\n<span class="line"><span style="color:#e1e4e8;">  }</span></span>\n<span class="line"><span style="color:#e1e4e8;">}</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">requestAnimationFrame(render);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">// 小球拖尾效果</span></span>\n<span class="line"><span style="color:#24292e;">const positions = [];</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">const render = () =&gt; {</span></span>\n<span class="line"><span style="color:#24292e;">  // 添加新位置</span></span>\n<span class="line"><span style="color:#24292e;">  positions.push({x, y});</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">  if (positions.length &gt; 10){</span></span>\n<span class="line"><span style="color:#24292e;">    positions.shift(); </span></span>\n<span class="line"><span style="color:#24292e;">  }</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">  // 渲染小球</span></span>\n<span class="line"><span style="color:#24292e;">  ctx.clearRect(0, 0, width, height);</span></span>\n<span class="line"><span style="color:#24292e;">  positions.forEach(pos =&gt; ctx.fillRect(pos.x, pos.y, 10, 10));</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">  requestAnimationFrame(render);</span></span>\n<span class="line"><span style="color:#24292e;">}</span></span>\n<span class="line"><span style="color:#24292e;">// SVG绘制动画</span></span>\n<span class="line"><span style="color:#24292e;">let length = 0;</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">const render = () =&gt; {</span></span>\n<span class="line"><span style="color:#24292e;">  length += 4;</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">  svgLine.setAttribute(&quot;stroke-dasharray&quot;, length);</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">  if (length &lt; 300) {</span></span>\n<span class="line"><span style="color:#24292e;">    requestAnimationFrame(render);</span></span>\n<span class="line"><span style="color:#24292e;">  }</span></span>\n<span class="line"><span style="color:#24292e;">}</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">requestAnimationFrame(render); </span></span>\n<span class="line"><span style="color:#24292e;">// 进度条加载动画  </span></span>\n<span class="line"><span style="color:#24292e;">let progress = 0;</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">const render = () =&gt; {</span></span>\n<span class="line"><span style="color:#24292e;">  progress += 1; </span></span>\n<span class="line"><span style="color:#24292e;">  loadBar.style.width = progress + &#39;%&#39;;</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">  if(progress &lt; 100) {</span></span>\n<span class="line"><span style="color:#24292e;">    requestAnimationFrame(render);</span></span>\n<span class="line"><span style="color:#24292e;">  }</span></span>\n<span class="line"><span style="color:#24292e;">}</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">requestAnimationFrame(render);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><h3 id="requestanimationframe在游戏开发中的应用" tabindex="-1">requestAnimationFrame在游戏开发中的应用 <a class="header-anchor" href="#requestanimationframe在游戏开发中的应用" aria-label="Permalink to &quot;requestAnimationFrame在游戏开发中的应用&quot;">​</a></h3><p>游戏需要非常流畅的画面和实时的响应,这正是<code>requestAnimationFrame</code>的优势,它可用于实现游戏中的物体移动、碰撞检测、帧数控制等操作。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">// 飞机射击动画</span></span>\n<span class="line"><span style="color:#e1e4e8;">const update = () =&gt; {</span></span>\n<span class="line"><span style="color:#e1e4e8;">  // 子弹位置更新</span></span>\n<span class="line"><span style="color:#e1e4e8;">  bullets.forEach(bullet =&gt; {</span></span>\n<span class="line"><span style="color:#e1e4e8;">    bullet.position += speed;</span></span>\n<span class="line"><span style="color:#e1e4e8;">  })</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">  // 飞机位置更新</span></span>\n<span class="line"><span style="color:#e1e4e8;">  aircraft.position += delta * speed;</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">  // 绘制所有元素</span></span>\n<span class="line"><span style="color:#e1e4e8;">  render(bullets, aircraft);</span></span>\n<span class="line"><span style="color:#e1e4e8;">  </span></span>\n<span class="line"><span style="color:#e1e4e8;">  requestAnimationFrame(update);</span></span>\n<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">// 飞机射击动画</span></span>\n<span class="line"><span style="color:#24292e;">const update = () =&gt; {</span></span>\n<span class="line"><span style="color:#24292e;">  // 子弹位置更新</span></span>\n<span class="line"><span style="color:#24292e;">  bullets.forEach(bullet =&gt; {</span></span>\n<span class="line"><span style="color:#24292e;">    bullet.position += speed;</span></span>\n<span class="line"><span style="color:#24292e;">  })</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">  // 飞机位置更新</span></span>\n<span class="line"><span style="color:#24292e;">  aircraft.position += delta * speed;</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">  // 绘制所有元素</span></span>\n<span class="line"><span style="color:#24292e;">  render(bullets, aircraft);</span></span>\n<span class="line"><span style="color:#24292e;">  </span></span>\n<span class="line"><span style="color:#24292e;">  requestAnimationFrame(update);</span></span>\n<span class="line"><span style="color:#24292e;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="requestanimationframe在响应式设计中的应用" tabindex="-1">requestAnimationFrame在响应式设计中的应用 <a class="header-anchor" href="#requestanimationframe在响应式设计中的应用" aria-label="Permalink to &quot;requestAnimationFrame在响应式设计中的应用&quot;">​</a></h3><p>可使用<code>requestAnimationFrame</code>来更平滑地执行响应式布局的变化,避免布局突然大幅移动带来的视觉冲击感。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">let width = 500;</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">const resize = () =&gt; {</span></span>\n<span class="line"><span style="color:#e1e4e8;">  width = container.clientWidth;</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">  box.style.width = width + &quot;px&quot;;</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">  requestAnimationFrame(resize);</span></span>\n<span class="line"><span style="color:#e1e4e8;">}</span></span>\n<span class="line"><span style="color:#e1e4e8;"></span></span>\n<span class="line"><span style="color:#e1e4e8;">window.addEventListener(&quot;resize&quot;, resize);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">let width = 500;</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">const resize = () =&gt; {</span></span>\n<span class="line"><span style="color:#24292e;">  width = container.clientWidth;</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">  box.style.width = width + &quot;px&quot;;</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">  requestAnimationFrame(resize);</span></span>\n<span class="line"><span style="color:#24292e;">}</span></span>\n<span class="line"><span style="color:#24292e;"></span></span>\n<span class="line"><span style="color:#24292e;">window.addEventListener(&quot;resize&quot;, resize);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="兼容性和后续发展" tabindex="-1">兼容性和后续发展 <a class="header-anchor" href="#兼容性和后续发展" aria-label="Permalink to &quot;兼容性和后续发展&quot;">​</a></h2><h3 id="requestanimationframe的浏览器兼容性" tabindex="-1">requestAnimationFrame的浏览器兼容性 <a class="header-anchor" href="#requestanimationframe的浏览器兼容性" aria-label="Permalink to &quot;requestAnimationFrame的浏览器兼容性&quot;">​</a></h3><p><code>requestAnimationFrame</code>现在已经得到了广泛支持,可以直接使用。对于不支持的浏览器,可以用<code>setTimeout</code>模拟<code>requestAnimationFrame</code>。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">window.requestAnimationFrame = window.requestAnimationFrame ||</span></span>\n<span class="line"><span style="color:#e1e4e8;">                               window.webkitRequestAnimationFrame ||</span></span>\n<span class="line"><span style="color:#e1e4e8;">                               (cb =&gt; setTimeout(cb, 1000/60));</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">window.requestAnimationFrame = window.requestAnimationFrame ||</span></span>\n<span class="line"><span style="color:#24292e;">                               window.webkitRequestAnimationFrame ||</span></span>\n<span class="line"><span style="color:#24292e;">                               (cb =&gt; setTimeout(cb, 1000/60));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="requestanimationframe的未来发展趋势" tabindex="-1">requestAnimationFrame的未来发展趋势 <a class="header-anchor" href="#requestanimationframe的未来发展趋势" aria-label="Permalink to &quot;requestAnimationFrame的未来发展趋势&quot;">​</a></h3><p>未来<code>requestAnimationFrame</code>可能会支持设置帧率、增强调度算法等,提升动画性能。Web工作者线程也可带来更多优化空间。</p><p>浏览器厂商也在继续改进相关API,比如<code>setTimeout</code>和<code>requestIdleCallback</code>也在朝着更精确的调度方向发展。</p><h3 id="如何在不支持requestanimationframe的浏览器中实现类似效果" tabindex="-1">如何在不支持requestAnimationFrame的浏览器中实现类似效果 <a class="header-anchor" href="#如何在不支持requestanimationframe的浏览器中实现类似效果" aria-label="Permalink to &quot;如何在不支持requestAnimationFrame的浏览器中实现类似效果&quot;">​</a></h3><p>可以通过自己实现一个<code>polyfill</code>:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">window.requestAnimationFrame = window.requestAnimationFrame || </span></span>\n<span class="line"><span style="color:#e1e4e8;">                               window.webkitRequestAnimationFrame ||</span></span>\n<span class="line"><span style="color:#e1e4e8;">                               (cb =&gt; setTimeout(cb, 1000/60));</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">window.requestAnimationFrame = window.requestAnimationFrame || </span></span>\n<span class="line"><span style="color:#24292e;">                               window.webkitRequestAnimationFrame ||</span></span>\n<span class="line"><span style="color:#24292e;">                               (cb =&gt; setTimeout(cb, 1000/60));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这样就可以在大多数浏览器中使用 <code>requestAnimationFrame</code> 了。对于老旧浏览器，可以使用 <code>setInterval</code> 模拟，但效果会比较粗糙。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p><code>requestAnimationFrame</code>是实现复杂动画的好帮手,必须掌握其用法与优化技巧,才能发挥其最大效用。同时结合其他技术如CSS动画、Web Worker等也可以实现更好的性能。随着浏览器的不断进步,<code>requestAnimationFrame</code>还具有很大的拓展潜力。</p><p><img src="/assets/wechat.21b4a9ec.png" alt="wechat"></p>',62);const d=s(c,[["render",function(s,r,i,t,o,c){const d=n("ArticleMetadata"),b=n("ClientOnly");return a(),e("div",null,[m,l(b,null,{default:p((()=>[l(d)])),_:1}),u])}]]);export{o as __pageData,d as default};
