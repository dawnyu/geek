import{_ as s,C as a,o as n,c as l,H as p,w as o,k as e,a as t,Q as c}from"./chunks/framework.e34e23c1.js";const r=JSON.parse('{"title":"一文搞懂单线程和事件循环","description":"","frontmatter":{"layout":"Article","title":"一文搞懂单线程和事件循环","date":"2023/10/10","tags":"JavaScrpit","category":"技术专栏","preview":"/common/79.jpg","intro":"JavaScript是一种单线程语言，它在任何给定时间只能执行一个任务。然而js确能够处理异步操作，这得益于其事件循环（Event Loop）机制。今天这篇文章带领大家深入理解JavaScript单线程特性，以及讲解事件循环和js多线程知识。"},"headers":[],"relativePath":"article/一文搞懂单线程和事件循环.md","filePath":"全部文档/技术专栏/前端/一文搞懂单线程和事件循环.md","lastUpdated":1696945268000}'),i={name:"article/一文搞懂单线程和事件循环.md"},E=e("h1",{id:"一文搞懂单线程和事件循环",tabindex:"-1"},[t("一文搞懂单线程和事件循环 "),e("a",{class:"header-anchor",href:"#一文搞懂单线程和事件循环","aria-label":'Permalink to "一文搞懂单线程和事件循环"'},"​")],-1),y=c('<p>JavaScript是一种单线程语言，它在任何给定时间只能执行一个任务。然而JavaScript确能够处理异步操作，这得益于其事件循环（Event Loop）机制。今天这篇文章带领大家深入了解JavaScript单线程的工作原理。</p><h3 id="事件循环流程图" tabindex="-1">事件循环流程图 <a class="header-anchor" href="#事件循环流程图" aria-label="Permalink to &quot;事件循环流程图&quot;">​</a></h3><p>下面是一个事件循环的流程图：</p><p><img src="https://cdn.geekbuluo.com/blog/20231010/e3b65d.png" alt=""></p><p>事件循环的核心思想是，JavaScript引擎首先执行当前的同步任务，然后检查任务队列（Task Queue）中是否有待处理的异步任务。如果有，它会按照顺序将这些异步任务添加到执行队列，并在当前任务执行完毕后依次执行它们。</p><h3 id="代码示例" tabindex="-1">代码示例 <a class="header-anchor" href="#代码示例" aria-label="Permalink to &quot;代码示例&quot;">​</a></h3><p>让我们通过一个详细的JavaScript代码示例来说明事件循环的工作原理：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Start&#39;</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Async task 1 completed&#39;</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">        console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Async task 2 completed&#39;</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }, </span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">1000</span><span style="color:#E1E4E8;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;End&#39;</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Start&#39;</span><span style="color:#24292E;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>\n<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Async task 1 completed&#39;</span><span style="color:#24292E;">);</span></span>\n<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>\n<span class="line"><span style="color:#24292E;">        console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Async task 2 completed&#39;</span><span style="color:#24292E;">);</span></span>\n<span class="line"><span style="color:#24292E;">    }, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span>\n<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">1000</span><span style="color:#24292E;">);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;End&#39;</span><span style="color:#24292E;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>在这个示例中，我们首先输出&quot;Start&quot;，然后设置了两个嵌套的异步任务，它们会在不同的时间后输出&quot;Async task 1 completed&quot;和&quot;Async task 2 completed&quot;。最后输出&quot;End&quot;。这里是事件发生的顺序：</p><ol><li>执行&quot;Start&quot;同步任务。</li><li>设置第一个异步任务（setTimeout），它会在1秒后执行。</li><li>执行&quot;End&quot;同步任务。</li><li>等待1秒钟，此时没有同步任务需要执行，事件循环开始执行异步任务。</li><li>执行第一个异步任务，输出&quot;Async task 1 completed&quot;。</li><li>设置第二个异步任务（嵌套的setTimeout），它会在1秒后执行。</li><li>异步任务队列再次为空，事件循环继续执行同步任务。</li><li>1秒后，第二个异步任务执行，输出&quot;Async task 2 completed&quot;。</li></ol><p>这个示例清晰地展示了JavaScript单线程的工作原理，即在同步任务执行完毕后，事件循环才会处理异步任务。</p><h2 id="javascript单线程的影响" tabindex="-1">JavaScript单线程的影响 <a class="header-anchor" href="#javascript单线程的影响" aria-label="Permalink to &quot;JavaScript单线程的影响&quot;">​</a></h2><p>JavaScript的单线程性质对开发者有以下影响：</p><ol><li><p><strong>阻塞问题：</strong> 长时间运行的JavaScript代码会阻塞主线程，导致用户界面冻结。这会降低用户体验，因此开发者需要小心处理耗时操作，以确保界面响应迅速。</p></li><li><p><strong>异步编程：</strong> 为了处理异步任务，开发者需要使用回调函数、Promise、async/await等机制。这可以确保异步任务不会阻塞主线程，但也增加了代码的复杂性。</p></li><li><p><strong>竞态条件：</strong> 由于单线程性质，当多个异步任务竞争访问共享资源时，可能会导致竞态条件。开发者需要小心处理这些情况，以避免潜在的问题。</p></li><li><p><strong>性能优化：</strong> 为了充分利用多核处理器和提高性能，开发者需要使用Web Workers、Service Workers等技术来执行并行任务。</p></li></ol><p>尽管JavaScript是单线程的，但通过合理的异步编程和利用现代Web技术，开发者仍然能够构建高性能、响应迅速的Web应用程序。理解JavaScript单线程的工作原理对于每个Web开发者都至关重要，因为它将有助于更好地利用这门语言的潜力，并编写出更出色的Web应用程序。</p>',15);const u=s(i,[["render",function(s,e,t,c,r,i){const u=a("ArticleMetadata"),d=a("ClientOnly");return n(),l("div",null,[E,p(d,null,{default:o((()=>[p(u)])),_:1}),y])}]]);export{r as __pageData,u as default};
